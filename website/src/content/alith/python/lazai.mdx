import { Steps, Tabs } from "nextra/components";

# Blockchain Integration with LazAI

Alith provides seamless integration with the LazAI blockchain network, enabling decentralized AI services, data management, and secure computations. This integration allows your agents to interact with the Web3 ecosystem while maintaining privacy and security.

## What is LazAI?

LazAI is a decentralized AI platform that provides:

- **Decentralized Data Registry**: Store and manage data on-chain
- **Verified Computing**: Secure AI computations in TEE environments
- **Settlement System**: Automated billing and payments
- **Privacy Protection**: Encrypted data processing
- **Node Network**: Distributed AI service providers

## Why Use LazAI Integration?

### Traditional AI Services
```python
# Centralized approach - single point of failure
agent = Agent(
    model="gpt-4",
    api_key="your-api-key",
    base_url="https://api.openai.com/v1"
)
# Issues: Privacy concerns, vendor lock-in, single point of failure
```

### Decentralized AI with LazAI
```python
from alith.lazai import Client
import os

# Setup blockchain client
os.environ["PRIVATE_KEY"] = "0x..."
client = Client()

# Register user and deposit funds
client.add_user(amount=1000000000000000000)  # 1 ETH

# Use decentralized services
headers = client.get_request_headers(node="0xnode...")
response = requests.post(
    "https://node.example.com/query/rag",
    json={"query": "What is AI?", "file_id": 1},
    headers=headers
)
# Benefits: Privacy, decentralization, transparency, security
```

## Getting Started with LazAI

<Steps>

### 1. Setup Environment

```bash
# Set your private key
export PRIVATE_KEY="0x..."

# For local development
export LAZAI_LOCAL_CHAIN="true"

# For testnet
unset LAZAI_LOCAL_CHAIN
```

### 2. Initialize Client

```python
from alith.lazai import Client, ChainConfig, ContractConfig

# Use testnet (default)
client = Client()

# Use local development network
import os
os.environ["LAZAI_LOCAL_CHAIN"] = "true"
client = Client()

# Custom configuration
custom_config = ChainConfig(
    network="Custom Network",
    endpoint="https://custom-rpc.example.com",
    chain_id=12345
)
client = Client(chain_config=custom_config)
```

### 3. Check Wallet

```python
# Check balance
balance = client.get_balance()
print(f"Balance: {balance} wei ({balance / 1e18} ETH)")

# Get wallet address
print(f"Address: {client.wallet.address}")
```

</Steps>

## Data Management

### File Registration

Register files on the LazAI blockchain:

```python
# Add file without hash (legacy)
file_id = client.add_file("https://example.com/data.json")
print(f"File ID: {file_id}")

# Add file with content hash
tx_hash = client.add_file_with_hash(
    "https://example.com/dataset.json",
    "0xabc123def456..."
)
print(f"Transaction: {tx_hash}")

# Get file information
file_info = client.get_file(file_id)
print(f"File info: {file_info}")
# Returns: (id, owner, url, hash, proof_index, reward_amount)
```

### Permission Management

Control access to your data:

```python
# Grant permission to specific account
client.add_permission_for_file(
    file_id=1,
    account="0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    key="encrypted_aes_key_here"
)

# Check file permissions
key = client.get_file_permission(1, "0x742d35...")
print(f"Access key: {key}")

# Get file by URL
file_id = client.get_file_id_by_url("https://example.com/data.json")
```

### Data Proofs

Generate and verify data proofs:

```python
from alith.lazai import ProofData

# Create proof data
proof = ProofData(
    id=1,
    score=95,
    file_url="https://example.com/data.json",
    proof_url="https://example.com/proof.json"
)

# Add proof to blockchain
client.add_proof(1, proof)

# Get file proof
proof_info = client.get_file_proof(1, 0)
print(f"Proof: {proof_info}")
```

## Node Management

### Register Compute Nodes

Register your AI services on the network:

```python
# Register inference node
client.add_inference_node(
    address="0xnode1...",
    url="https://inference1.example.com",
    public_key="-----BEGIN PUBLIC KEY-----\n..."
)

# Register query node
client.add_query_node(
    address="0xnode2...",
    url="https://query1.example.com",
    public_key="-----BEGIN PUBLIC KEY-----\n..."
)

# Register training node
client.add_training_node(
    address="0xnode3...",
    url="https://training1.example.com",
    public_key="-----BEGIN PUBLIC KEY-----\n..."
)
```

### Node Information

Get information about network nodes:

```python
# Get all nodes
nodes = client.node_list()
print(f"Total nodes: {len(nodes)}")

# Get active nodes
active_nodes = client.active_node_list()
print(f"Active nodes: {len(active_nodes)}")

# Get specific node info
node_info = client.get_node("0xnode...")
print(f"Node info: {node_info}")
# Returns: (address, url, status, amount, jobs_count, public_key)

# Check if node exists
is_node = client.is_node("0xnode...")
print(f"Is node: {is_node}")
```

## Settlement System

### User Registration

Register users in the settlement system:

```python
# Register user with initial deposit
client.add_user(amount=1000000000000000000)  # 1 ETH

# Check user information
user_info = client.get_user(client.wallet.address)
print(f"User info: {user_info}")
# Returns: (addr, available_balance, total_balance, query_nodes, inference_nodes, training_nodes)

# Get all users
all_users = client.get_all_users()
print(f"Total users: {len(all_users)}")
```

### Fund Management

Manage funds for AI services:

```python
# Deposit funds to user account
client.deposit(1000000000000000000)  # 1 ETH

# Withdraw funds
client.withdraw(500000000000000000)  # 0.5 ETH

# Deposit for specific services
client.deposit_query("0xnode...", 100000000000000000)      # 0.1 ETH
client.deposit_inference("0xnode...", 200000000000000000)  # 0.2 ETH
client.deposit_training("0xnode...", 1000000000000000000)  # 1 ETH

# Retrieve funds from nodes
client.retrieve_query(["0xnode1...", "0xnode2..."])
client.retrieve_inference(["0xnode1..."])
client.retrieve_training(["0xnode1..."])
```

### Account Management

Check account balances and status:

```python
# Query account
query_account = client.get_query_account(
    client.wallet.address,
    "0xnode..."
)
print(f"Query account: {query_account}")
# Returns: (user, node, nonce, balance, pending_refund, refunds)

# Inference account
inference_account = client.get_inference_account(
    client.wallet.address,
    "0xnode..."
)

# Training account
training_account = client.get_training_account(
    client.wallet.address,
    "0xnode..."
)
```

## Service Integration

### Query Services

Use decentralized query services:

```python
import requests

# Generate request headers
headers = client.get_request_headers(
    node="0xnode...",
    file_id=1
)

# Query data
response = requests.post(
    "https://node.example.com/query/rag",
    json={
        "query": "What insights can you provide?",
        "file_id": 1
    },
    headers=headers
)

print(response.json())
```

### Inference Services

Use decentralized inference services:

```python
# Generate inference headers
headers = client.get_request_headers(
    node="0xnode...",
    file_id=1
)

# Make inference request
response = requests.post(
    "https://node.example.com/v1/chat/completions",
    json={
        "model": "llama-3.3-70b-versatile",
        "messages": [{"role": "user", "content": "Hello!"}]
    },
    headers=headers
)

print(response.json())
```

### Training Services

Use decentralized training services:

```python
from alith.training.types import TrainingParams, LoraParams

# Configure training
params = TrainingParams(
    model="Qwen/Qwen2-0.5B",
    training_type="sft",
    finetuning_type="lora",
    lora_params=LoraParams(rank=8, alpha=16),
    num_epochs=3,
    learning_rate=5e-5
)

# Generate training headers
headers = client.get_request_headers(node="0xnode...")

# Start training
response = requests.post(
    "https://node.example.com/v1/training",
    json=params.dict(),
    headers=headers
)

job_id = response.json()["job_id"]
print(f"Training job: {job_id}")

# Check training status
status_response = requests.get(
    f"https://node.example.com/v1/training/{job_id}"
)
status = status_response.json()
print(f"Progress: {status['percentage']}%")
```

## Privacy & Security

### TEE Integration

Use Trusted Execution Environments for secure computations:

```python
from alith.tee import PhalaTEE, MarlinTEE

# Phala TEE
phala_tee = PhalaTEE(
    cluster_id="your-cluster-id",
    worker_id="your-worker-id"
)

# Marlin TEE
marlin_tee = MarlinTEE(
    endpoint="your-marlin-endpoint",
    api_key="your-api-key"
)

# Secure computation
result = phala_tee.compute("sensitive_data", "computation_function")
```

### Data Encryption

Encrypt sensitive data:

```python
from alith.data import encrypt, decrypt

# Encrypt data
plaintext = b"Sensitive data here"
password = "my-secret-password"
encrypted = encrypt(plaintext, password)

# Decrypt data
decrypted = decrypt(encrypted, password)
assert decrypted == plaintext
```

### Privacy-Preserving AI

Use privacy-preserving AI techniques:

```python
from alith import Agent

# Agent with privacy data
agent = Agent(
    model="llama-3.3-70b-versatile",
    api_key="your-groq-api-key",
    base_url="https://api.groq.com/openai/v1",
    # Privacy settings
    extra_headers={
        "X-Privacy-Mode": "enabled",
        "X-Data-Encryption": "AES-256"
    }
)

# Process sensitive data
response = agent.prompt("Analyze this sensitive data: [encrypted_data]")
```

## Advanced Features

### Multi-Node Setup

Deploy across multiple nodes:

```python
# Register multiple nodes
nodes = [
    ("0xnode1...", "https://node1.example.com"),
    ("0xnode2...", "https://node2.example.com"),
    ("0xnode3...", "https://node3.example.com")
]

for address, url in nodes:
    client.add_inference_node(
        address=address,
        url=url,
        public_key="-----BEGIN PUBLIC KEY-----\n..."
    )

# Distribute load across nodes
def get_best_node():
    active_nodes = client.active_node_list()
    # Implement load balancing logic
    return active_nodes[0] if active_nodes else None

best_node = get_best_node()
headers = client.get_request_headers(node=best_node)
```

### Automated Settlements

Implement automated billing:

```python
class AutomatedSettlement:
    def __init__(self, client):
        self.client = client
        self.settlement_threshold = 1000000000000000000  # 1 ETH
    
    def check_balance(self, user: str, node: str) -> bool:
        account = self.client.get_inference_account(user, node)
        balance = account[3]  # Balance field
        return balance >= self.settlement_threshold
    
    def auto_deposit(self, user: str, node: str, amount: int):
        if not self.check_balance(user, node):
            self.client.deposit_inference(node, amount)
            print(f"Auto-deposited {amount} wei to {node}")
    
    def process_settlement(self, user: str, node: str, cost: int):
        # Process settlement after service usage
        self.client.inference_settlement_fees(
            SettlementData(
                id="unique_id",
                user=user,
                cost=cost,
                nonce=1,
                user_signature="signature"
            )
        )
```

### Data Analytics

Track usage and performance:

```python
class DataAnalytics:
    def __init__(self, client):
        self.client = client
        self.usage_stats = {}
    
    def track_usage(self, user: str, service: str, cost: int):
        if user not in self.usage_stats:
            self.usage_stats[user] = {}
        
        if service not in self.usage_stats[user]:
            self.usage_stats[user][service] = {"count": 0, "total_cost": 0}
        
        self.usage_stats[user][service]["count"] += 1
        self.usage_stats[user][service]["total_cost"] += cost
    
    def get_user_stats(self, user: str) -> dict:
        return self.usage_stats.get(user, {})
    
    def get_network_stats(self) -> dict:
        total_users = len(self.client.get_all_users())
        total_nodes = self.client.nodes_count()
        active_nodes = self.client.active_nodes_count()
        
        return {
            "total_users": total_users,
            "total_nodes": total_nodes,
            "active_nodes": active_nodes,
            "network_health": active_nodes / total_nodes if total_nodes > 0 else 0
        }
```

## Best Practices

### 1. Security

```python
# Always use environment variables for private keys
import os
private_key = os.getenv("PRIVATE_KEY")
if not private_key:
    raise ValueError("PRIVATE_KEY environment variable not set")

# Validate addresses
def validate_address(address: str) -> bool:
    return address.startswith("0x") and len(address) == 42

# Use secure random nonces
import secrets
nonce = secrets.randbelow(2**256)
```

### 2. Error Handling

```python
def robust_blockchain_operation(operation_func, *args, **kwargs):
    """Execute blockchain operations with error handling"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            return operation_func(*args, **kwargs)
        except Exception as e:
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Exponential backoff
                continue
            raise e

# Usage
try:
    file_id = robust_blockchain_operation(
        client.add_file,
        "https://example.com/data.json"
    )
    print(f"Success: {file_id}")
except Exception as e:
    print(f"Error: {e}")
```

### 3. Gas Optimization

```python
def optimize_gas_usage(client):
    """Optimize gas usage for blockchain operations"""
    # Check gas price
    gas_price = client.get_gas_price()
    print(f"Current gas price: {gas_price} wei")
    
    # Estimate gas for transaction
    estimated_gas = client.estimated_gas(
        to=contract_address,
        value=0,
        data=transaction_data
    )
    
    # Use appropriate gas limit
    gas_limit = int(estimated_gas * 1.2)  # 20% buffer
    return gas_limit
```

## Common Issues

### 1. Transaction Failures

**Problem**: Blockchain transactions fail
**Solutions**:
- Check gas price and limits
- Ensure sufficient balance
- Verify contract addresses
- Check nonce issues

```python
# Check balance before transaction
balance = client.get_balance()
if balance < 1000000000000000000:  # 1 ETH
    print("Insufficient balance")

# Check gas price
gas_price = client.get_gas_price()
if gas_price > 20000000000:  # 20 gwei
    print("Gas price too high, waiting...")
    time.sleep(60)
```

### 2. Network Connectivity

**Problem**: Cannot connect to blockchain
**Solutions**:
- Check RPC endpoint
- Verify network configuration
- Use fallback endpoints
- Implement retry logic

```python
# Use multiple RPC endpoints
endpoints = [
    "https://mainnet.infura.io/v3/your-key",
    "https://eth-mainnet.alchemyapi.io/v2/your-key",
    "https://rpc.ankr.com/eth"
]

for endpoint in endpoints:
    try:
        client = Client(chain_config=ChainConfig(endpoint=endpoint))
        break
    except Exception as e:
        print(f"Failed to connect to {endpoint}: {e}")
        continue
```

### 3. Private Key Issues

**Problem**: Private key not working
**Solutions**:
- Verify key format
- Check key permissions
- Use proper key derivation
- Secure key storage

```python
# Validate private key format
def validate_private_key(key: str) -> bool:
    if not key.startswith("0x"):
        key = "0x" + key
    
    if len(key) != 66:
        return False
    
    try:
        int(key, 16)
        return True
    except ValueError:
        return False

# Secure key storage
import keyring
def store_private_key(key: str):
    keyring.set_password("alith", "private_key", key)

def get_private_key():
    return keyring.get_password("alith", "private_key")
```

## Integration Examples

### 1. Decentralized AI Assistant

```python
class DecentralizedAssistant:
    def __init__(self, model, api_key, base_url):
        self.client = Client()
        self.agent = Agent(
            model=model,
            api_key=api_key,
            base_url=base_url
        )
        self.nodes = self.client.active_node_list()
    
    def query_data(self, query: str, file_id: int) -> str:
        """Query data using decentralized services"""
        # Get best node
        node = self.get_best_node()
        
        # Generate headers
        headers = self.client.get_request_headers(node=node, file_id=file_id)
        
        # Make request
        response = requests.post(
            f"https://{node}/query/rag",
            json={"query": query, "file_id": file_id},
            headers=headers
        )
        
        return response.json()
    
    def get_best_node(self) -> str:
        """Get the best available node"""
        if not self.nodes:
            raise Exception("No active nodes available")
        return self.nodes[0]  # Simple selection
    
    def add_knowledge(self, url: str) -> int:
        """Add knowledge to the network"""
        file_id = self.client.add_file(url)
        print(f"Added knowledge with ID: {file_id}")
        return file_id

# Usage
assistant = DecentralizedAssistant(
    model="llama-3.3-70b-versatile",
    api_key="your-groq-api-key",
    base_url="https://api.groq.com/openai/v1"
)

# Add knowledge
file_id = assistant.add_knowledge("https://example.com/knowledge.json")

# Query knowledge
response = assistant.query_data("What is the main topic?", file_id)
```

### 2. Privacy-Preserving AI Service

```python
class PrivacyPreservingService:
    def __init__(self, client):
        self.client = client
        self.encryption_key = "your-encryption-key"
    
    def process_sensitive_data(self, data: str, user: str) -> str:
        """Process sensitive data with privacy protection"""
        # Encrypt data
        encrypted_data = encrypt(data.encode(), self.encryption_key)
        
        # Use TEE for processing
        result = self.process_in_tee(encrypted_data)
        
        # Update user account
        self.update_user_usage(user, len(data))
        
        return result
    
    def process_in_tee(self, encrypted_data: bytes) -> str:
        """Process data in trusted execution environment"""
        # Implement TEE processing
        return "Processed result"
    
    def update_user_usage(self, user: str, data_size: int):
        """Update user usage statistics"""
        # Implement usage tracking
        pass
```

## Next Steps

Now that you understand blockchain integration, explore:

- **[Advanced Features](./advanced.mdx)** - TEE, training, and optimization
- **[Examples](../examples/)** - Real-world implementations
- **[API Reference](./api-reference.mdx)** - Complete API documentation
